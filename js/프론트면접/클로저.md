## 메모리의 구조

![image](https://media.vlpt.us/images/goserimgoserimgo/post/5e3e1d1f-94d8-4e09-b55f-620ebb00c071/_2020-08-02__10.36.08.png)

- text -> 코드를 실행하기 위해 저장되어 있는 영역
- data -> 글로벌한 변수들은 힙에 저장되지 않고 여기에 저장됨
- bss -> data에서 초기화되지 않은 변수 영역은 BSS(Block Started by Symbol)
- heap -> 다이나믹하게 생기는 거 저장 클로저 같은거
  - 흔히 동적으로 할당 할 변수들이 여기에 저장
- stack -> 함수들 저장
  - 스택 영역은 함수를 호출 할 때 지역변수, 매개변수들이 저장되는 공간

인스턴스에 할당 되었다는것은

다른메모리가 생겨 적재가 되었다는 것!

## 함수의 실행 되었을때의 환경을 기억하는것

스택에서 쌓아지는 펑션들은 실행 후 사라지더라도

힙에 저장되어 있는 참조중인 변수들을 사용해 클로저를 구현한다.

간단하게 커링을 통한 예제로 알아보면

```js
const add = (a) => (b) => a + b;
```

같은 함수가 있을때

```js
const add10 = add(10); // 함수를 리턴하여 할당

console.log(add10(20)); // 20
```

클로저가 add의 a(10)를 기억하고 있다가 다음 인자가 들어왔을때 실행되는것.

어느곳에서도 함수의 내부 변수를 참조하지 않을 때 가비지 컬렉션에 의해 메모리에서 지워지게 된다.

가비지 컬렉션은 힙 영역에서 참조하는 애가 있는지 확인하고 없으면 제거해줌

### 클로저로 캡슐화

```js
const test = () => {
  const name = "kim";
  return name;
};
```

저 name이라는 변수의 값을 수정 할 수 있는 방법이 없다.

이렇게 캡슐화로 private 변수를 만들 수 있따.
