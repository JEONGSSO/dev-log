# 함수형프로그래밍 간단 정의

함수형 사고방식은 문제의 해결 방법을 동사 (함수)들의 구성으로 접근하는 것.
 
함수형 프로그래밍(FP) 방식?
성공적인 프로그래밍을 위해 부수효과(Side Effect)를 최대한 멀리하고 조합성을 강조하는 방식.

FP가 부수효과를 최대한 멀리하는 이유?
오류를 줄이기 위해 or 조합성 모듈화 수준을 높이기 위해
 
```js
FP 간단한 예제
function addMaker(a) {
	return function(b) {
    	return a + b
    }
}
```

addMaker(10)(5) // 10은 a인자로, 5는 b인자로 15
// (10) 이 먼저 실행 돼 b를 인자로 받는 익명함수를 리턴해 10+5가 실행.
addMaker는 함수를 값으로 다루는 함수다. 단 하나의 값이 선언 되며 그 값은 함수다.

간단하지만 값으로서의 함수, 클로저, 스코프 등의 많은 이야기를 담음.

 

함수는 값을 리턴할 수 있고 함수는 값이 될 수 있다.

addMaker는 내부에서 익명함수를 정의하고 리턴, 클로저가 됨 a가 정의된 적은 없지만 a를 참조하고 있는

a는 부모스코프에 있다.

함수형 프로그래밍은 같은 입력이면 항상 같은 출력이 나온다는 것을 기본으로 둔다.

```js
const users = [
  {id:1, name : "kim", age: 30},
  {id:2, name : "park", age: 29},
  {id:3, name : "lee", age: 28},
  {id:4, name : "hong", age: 27},
  {id:5, name : "han", age: 32},
  {id:6, name : "kang", age: 31}
]

function filter(list, predicate) {
  for(let i = 0 ; i < list.length; i++) {
    if(predicate(list[i] ,29)) {
      console.log(list[i])
    }
  }
}

const predicate = (Lists ,age) => Lists.age > age

filter(users, predicate)
```

함수 filter는 같은 값을 넣으면 항상 같은 값을 리턴한다.

두 번째 인자로 받은 predicate 함수에서 조건문의 조건을 판단

이처럼 항상 동일하게 동작하는 함수(filter)를 만들고 보조함수(predicate)를 조합하는 식으로 로직 완성.