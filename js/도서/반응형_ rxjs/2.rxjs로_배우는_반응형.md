- 객체지향 방식으로 코드를 작성할 때 문제를 컴포넌트, 상호작용, 상태로 분해하는 방법을 보았습니다.
- 분해를 반복적으로 많은 수준에서 일어나며
- 이를 통해 마지막으로 응집성있는 클래스를 얻을때까지 세분화 됩니다.
- 객체지향 방식은 클래스가 주요 작업단위입니다.

- RP에서 기본단위는 스트림입니다.

- 데이터는 강물처럼 한 방향으로만 이동하며 데이터를 변형시키는 방식으로 하고 시간 개념이 가장 중요합니다.
- PR는 FP위에 구축되므로 FP가 결국 PR의 기초라 볼 수 있다.

- ReactiveX는 옵저버 패턴고ㅘ 이터레이터 패턴, 그리고 fp에서 나온 최상의 아이디어를 조합한 것.

- 1장에서 옵저버 패턴의 주요 컴포넌트 생산자와 소비자를 배웠고,
- 이번에는 rx를 구현하는 fp와 이터레이터를 배우겠습니다.

## 함수형 프로그래밍

- FP는 선언적이고 불변하며 side effect이 없는 코드를 짜도록 강조하는 패러다임
- 함수체인, 지연평가를 사용합니다.

- 세가지의 특징이 있습니다.

- 선언적
- 불변성
- side effect

- 변이와 부가작용은 함수들을 신뢰할 수 없습니다.
- 함수가 객체를 변경하게되면 그 객체를 바라보는 다른 함수의 역할을 기대하지 못하기때문에 지양해야 합니다.
- 유지해야 하는 코드가 전역일 수록 코드 유지나 관리가 어려워짐

- 동시성 비동기 프로그래밍이 있는 경우 지연 시간을 예측할 수 없으므로 함수 호출을 중첩하거나 다른 방법으로 상태를 올바른 순서로 실행하고 변경해야 함.
- 다행히 js는 싱글 스레드이므로 다른 스레드의 상태를 걱정할 필요는 없지만, 웹워커나 http 호출을 동시에 하는경우에 시간을 잘 다뤄야 합니다.

- 고차, 일급 함수로 함수형 기능을 사용할 수 있게 합니다.
- 동일한 입력에는 항상 동일한 값을 리턴하는게 핵심. 이것이 순수함수
-

```js
Strame([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
  .filter(isEven)
  .map(squere)
  .reduce(add)
  .subscribe(console.log); // 220
```

- 객체 값의 동적인 동작은 선언적이고 불변하게 지정

- 그림 2-4
- FP에서 차용한 스트림의 또 다른 디자인 원칙은 지연평가를 사용합니다

- 지연평가는 스트림에서 마우스 움직임과 키입력 등 무수한 이벤트를 실행시키는 데 지연평가를 통해 이벤트가 호출되었을때만 평가를 할 수 있다.

- 이터레이터 패턴

- rxjs스트림의 핵심 디자인 원칙은 배열처럼 친숙한 탐색 매커니즘을 제공하는 것
- 또한 이 패턴은 반복 자체에서 각 요소에 적용된 비즈니스 로직을 분리하는데 효과적

- 자바스립트 es6표준이 이터레이터 프로토콜을 정의하며
- 가장 친숙한 반복 가능 객체는 배열과 문자열과 es6에서 추가된 map과 set까지 사용합니다.

- 데이터를 전면에 내세워 시스템 동작과 분리하는 것이 데이터 기반/데이터 중심 디자인의 핵심

- 생산자는 모든 모양과 크기로 제공됨 그중 이벤트 이미터가 가장 일반적이고 마우스 클릭이나 웹 요청같은 이벤트에 응답
- 시간관련 setTimeout과 setInterval과 같은 소스도 있습니다.

- 이벤트 이미터에는 이벤트 핸들러가 필요하고
- Promise에는 태너블
- setTimeout에는 콜백
- 배열은 반복을 위한 루프가 필요

- 이러한 테이터 소스를 동일한 방식으로 통합하고 처리할 수 있다!?

## rx Observable로 데이터 소스 감싸기

- 방출 데이터
  - 시스템과 일종의 상호 작용 결과로 생성되는 데이터입니다. ex) 마우스 클릭과 같은 사용자 상호작용
- 정적 데이터
  - 이미 존재하며 메모리에 있는 데이터 입니다, ex) 배열또는 문자열이 이 범주에 속함
- 생성 데이터
  - 주기적 또는 최종으로 생성하는 데이터입니다. ex) setTimeout과 setInterval 함수 등등

### 2.3.2 rxjs 옵저버블 생성

- 옵저버블은 현재 값이 아니라 미래에 발생할 값에 대한 개념을 나타낸다는 점을 이해하는것이 중요!

### 2.3.3 언제 어디서 rxjs를 사용하는가

- 데이터 소스의 타입은 크게 네개의 범주로 나눌 수 있는데

1. 단일 값 동기

- 가장 단순한 경우
- Rx.Observable.of() 함수에서 동기 값을 래핑하고 구독자가 연결되면 바로 방출함

2. 다중 값, 동기

- 단일 항목을 그룹화해서 배열을 중심으로 사용하는것 단일값이랑 사용방법 비슷하다.
- 동기적으로 순서대로 하나씩 처리됨

3. 단일 값, 비동기

- 코드 보면 Promise는 단일 값이고 불변하므로 다시 실행되지 않고, 콘솔이 실행된 후 43이 찍힘
- 다른 방법으로는 제이쿼리 get이나, fetch같은 함수를 자주 사용한다

4. 다중 값 비동기

- 시간이 지남에 따라 여러 값을 생성하지만 비동기로 수행하는 작업
- 특히 비동기이며 무한히 여러 번 발생할 수 있는 DOM이벤트 모두에 이 방식이 사용됨
- 즉 이터레이터와 Promise패턴의 의미가 혼합 되어야 함
- 코드의 제어구조를 역전하여 비동기로 작동해야 함
- EventEmitter를 사용하면 다중 값 비동기 이벤트 처리 두가지 기준을 모두 충족!

### 2.3.4 전달하거나 전달하지 않거나

- 이벤트 이미터는 일련의 이벤트를 비동기로 파싱하는데 이로한해 이터레이터와 매우 유사해지므로 스트림이라 할 수 있다.
- 하지만 데이터를 요청하든 전송하든 클라이언트가 데이터를 소비하는 방식에 차이가 있다.
- 옵저버블을 푸시 기반으로 컬렉션을 표현하는 객체로 정의하므로 이해하는것이 매우 중요합니다.

- 그림 2-12

- 이터레이터는 풀 기반 방식
- 즉 이터레이터의 소비자는 이터레이터에게 다음 대상을 요청해야 함
- 이 풀 데이터 모델에는 두 가지 이점이 있습니다.

  1.  사용중인 자료구조에 대한 추상화를 만듬
  2.  연산에서 발생하는 데이터에 관한것으로 제네레이터를 이용한 연산이 이에 해당함

- 무한한 피보나치 수열에 대해서는 next메서드로 요청한 횟수만큼만 계산하면된다.

- 풀 기반 패러다임은 연산에서 값을 즉시 반환할 수 있음을 알고 있을때 유용

  - 바로 방출하는것

- 마우스 클릭같은 시나리오에는 풀기반을 사용하기보다
- 클릭이 되었을때 반응하는 푸시기반이 더 적절함

- rxjs 옵저버블은 푸시 기반 알림을 사용함

- 다음 세가지 이유로 데이터 생성과 데이터 소비라는 두 개념의 분리와 추상화가 중요하다는 점을 강조합니다.

1. 공통 인터페이스를 사용하지만 작업의 비즈니스 로직에 좀 더 집중할 수 있다.
2. 생산과 소비를 분리하면 데이터 흐름 방향이 분명해지고 부분을 명확하게 분리가능
3. 생산자의 mock 버전을 결합하고 옵저버가 기대하는 것과 상응하게 연결함으로서 스트림 테스트 가능

- 풀 (이터레이터) 값이 있어야 함
- 푸시 값이 들어오면 반응

## 2.4 옵저버로 데이터 사용하기
