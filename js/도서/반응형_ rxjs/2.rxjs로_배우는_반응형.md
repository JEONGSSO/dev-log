스트림

옵저버 소비자

옵저버블 판매자

순수함수

파이프라인

- 객체지향 방식으로 코드를 작성할 때 문제를 컴포넌트, 상호작용, 상태로 분해하는 방법을 보았습니다.
- 분해를 반복적으로 많은 수준에서 일어나며
- 이를 통해 마지막으로 응집성있는 클래스를 얻을때까지 세분화 됩니다.
- 객체지향 방식은 클래스가 주요 작업단위입니다.

---

- RP에서 기본단위는 스트림입니다.
- 데이터는 강물처럼 한 방향으로만 이동하며 데이터를 변형시키는 방식으로 하고 시간 개념이 가장 중요합니다.
- PR는 FP위에 구축되므로 FP가 결국 PR의 기초라 볼 수 있다.
- ReactiveX는 옵저버 패턴과 이터레이터 패턴, 그리고 fp에서 나온 최상의 아이디어를 조합한 것.
- 1장에서 옵저버 패턴의 주요 컴포넌트 생산자와 소비자를 배웠고,
- 이번에는 rx를 구현하는 fp와 이터레이터를 배우겠습니다.

## 2.1 반응형 프로그래밍의 기초인 함수형 프로그래밍

### 2.1.1 함수형 프로그래밍

- FP는 선언적이고 불변하며 side effect이 없는 코드를 짜도록 강조하는 패러다임
- 함수체인, 지연평가를 사용합니다.

---

- 세가지의 특징이 있습니다.

- 선언적 -> 무엇을 하는지를 코딩하는것
- 불변성 -> 데이터를 생성한 후나 변수가 선언된 후에 수정하지 않는 것
- side effect 없음 -> 함수가 실행되었을때 함수 스코프 밖에 코드를 건드리는 것을 최소한으로 해야함

---

- 변이와 부가작용은 함수들을 신뢰할 수 없습니다.

- 함수가 객체를 변경하게되면 그 객체를 바라보는 다른 함수의 역할을 기대하지 못하기때문에 지양해야 합니다.

- 유지해야 하는 코드가 전역일 수록 코드 유지나 관리가 어려워짐

---

- 동시성 비동기 프로그래밍이 있는 경우 지연 시간을 예측할 수 없으므로 함수 호출을 중첩하거나 다른 방법으로 상태를 올바른 순서로 실행하고 변경해야 함.
- 다행히 js는 싱글 스레드이므로 다른 스레드의 상태를 걱정할 필요는 없지만, 웹워커나 http 호출을 동시에 하는경우에 시간을 잘 다뤄야 함.

---

- js는 함수형 언어가 아니지만 고차, 일급 함수로 함수형 기능을 사용할 수 있습니다.

- 순수함수, 동일한 입력에는 항상 동일한 값을 리턴하는게 핵심.

  ```js
  Strame([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    .filter(isEven)
    .map(squere)
    .reduce(add)
    .subscribe(console.log); // 220
  ```

- 객체 값의 동적인 동작은 선언적이고 불변하게 지정

- 그림 2-4
- FP에서 차용한 스트림의 또 다른 디자인 원칙은 지연평가를 사용합니다

- 지연평가는 스트림에서 마우스 움직임과 키입력 등 무수한 이벤트를 실행시키는 데 지연평가를 통해 이벤트가 호출되었을때만 평가를 할 수 있다.

---

### 2.1.2 이터레이터 패턴

- rxjs스트림의 핵심 디자인 원칙은 배열처럼 친숙한 탐색 매커니즘을 제공하는 것
- 또한 이 패턴은 반복 자체에서 각 요소에 적용된 비즈니스 로직을 분리하는데 효과적

- 자바스립트 es6표준이 이터레이터 프로토콜을 정의하며
- 가장 친숙한 반복 가능 객체는 배열과 문자열과 es6에서 추가된 map과 set까지 사용합니다.

- 데이터를 전면에 내세워 시스템 동작과 분리하는 것이 데이터 기반/데이터 중심 디자인의 핵심

- 생산자는 모든 모양과 크기로 제공됨 그중 이벤트 이미터가 가장 일반적이고 마우스 클릭이나 웹 요청같은 이벤트에 응답
- 시간관련 setTimeout과 setInterval과 같은 소스도 있습니다.

---

- 이벤트 이미터에는 이벤트 핸들러가 필요하고
- Promise에는 태너블
- setTimeout에는 콜백
- 배열은 반복을 위한 루프가 필요

- 이러한 테이터 소스를 동일한 방식으로 통합하고 처리할 수 있다면!?

---

## rx Observable로 데이터 소스 감싸기

- 방출 데이터
  - 시스템과 일종의 상호 작용 결과로 생성되는 데이터입니다. ex) 마우스 클릭과 같은 사용자 상호작용
- 정적 데이터
  - 이미 존재하며 메모리에 있는 데이터 입니다, ex) 배열또는 문자열이 이 범주에 속함
- 생성 데이터
  - 주기적 또는 최종으로 생성하는 데이터입니다. ex) setTimeout과 setInterval 함수 등등

### 2.3.2 rxjs 옵저버블 생성

- 옵저버블은 현재 값이 아니라 미래에 발생할 값에 대한 개념을 나타낸다는 점을 이해하는것이 중요!

### 2.3.3 언제 어디서 rxjs를 사용하는가

- 데이터 소스의 타입은 크게 네개의 범주로 나눌 수 있는데

1. 단일 값 동기

   - 가장 단순한 경우
   - Rx.Observable.of() 함수에서 동기 값을 래핑하고 구독자가 연결되면 바로 방출함

2. 다중 값, 동기
   - 단일 항목을 그룹화해서 배열을 중심으로 사용하는것 단일값이랑 사용방법 비슷하다.

- 동기적으로 순서대로 하나씩 처리됨

3. 단일 값, 비동기

   - 코드 보면 Promise는 단일 값이고 불변하므로 다시 실행되지 않고, 콘솔이 실행된 후 43이 찍힘
   - 다른 방법으로는 제이쿼리 get이나, fetch같은 함수를 자주 사용한다

4. 다중 값 비동기
   - 시간이 지남에 따라 여러 값을 생성하지만 비동기로 수행하는 작업
   - 특히 비동기이며 무한히 여러 번 발생할 수 있는 DOM이벤트 모두에 이 방식이 사용됨
   - 즉 이터레이터와 Promise패턴의 의미가 혼합 되어야 함
   - 코드의 제어구조를 역전하여 비동기로 작동해야 함
   - EventEmitter를 사용하면 다중 값 비동기 이벤트 처리 두가지 기준을 모두 충족!

### 2.3.4 전달하거나 전달하지 않거나

- 이벤트 이미터는 일련의 이벤트를 비동기로 파싱하는데 이로한해 이터레이터와 매우 유사해지므로 스트림이라 할 수 있다.
- 하지만 데이터를 요청하든 전송하든 클라이언트가 데이터를 소비하는 방식에 차이가 있다.
- 옵저버블을 푸시 기반으로 컬렉션을 표현하는 객체로 정의하므로 이해하는것이 매우 중요합니다.

- 그림 2-12

- 이터레이터는 풀 기반 방식
- 즉 이터레이터의 소비자는 이터레이터에게 다음 대상을 요청해야 함
- 이 풀 데이터 모델에는 두 가지 이점이 있습니다.

  1.  사용중인 자료구조에 대한 추상화를 만듬
  2.  연산에서 발생하는 데이터에 관한것으로 제네레이터를 이용한 연산이 이에 해당함

- 무한한 피보나치 수열에 대해서는 next메서드로 요청한 횟수만큼만 계산하면된다.

- 풀 기반 패러다임은 연산에서 값을 즉시 반환할 수 있음을 알고 있을때 유용

  - 바로 방출하는것

- 마우스 클릭같은 시나리오에는 풀기반을 사용하기보다
- 클릭이 되었을때 반응하는 푸시기반이 더 적절함

- rxjs 옵저버블은 푸시 기반 알림을 사용함

- 다음 세가지 이유로 데이터 생성과 데이터 소비라는 두 개념의 분리와 추상화가 중요하다는 점을 강조합니다.

1. 공통 인터페이스를 사용하지만 작업의 비즈니스 로직에 좀 더 집중할 수 있다.
2. 생산과 소비를 분리하면 데이터 흐름 방향이 분명해지고 부분을 명확하게 분리가능
3. 생산자의 mock 버전을 결합하고 옵저버가 기대하는 것과 상응하게 연결함으로서 스트림 테스트 가능

- 풀 (이터레이터) 값이 있어야 함
- 푸시 값이 들어오면 반응

## 2.4 옵저버로 데이터 사용하기

- 이터레이터는 반복되는 데이터 구조의 크기나 종료 여부는 모르고 처리할 데이터가 더 있는지 그 여부만 알 수 있습니다.
- 옵저버블은 간단한 이터레이터 유사 API로 더 많은 이벤트가 발생했는지 여부를 구독자에게 알릴 수 있습니다.

### 2.4.1 Observer API

- next, complete, error세가지의 api가 있다.

| 이름                   | 설명                                                                    |
| ---------------------- | ----------------------------------------------------------------------- |
| next(val): void        | 단일 함수가 옵저버 객체대신 subscribe()에 전달되면 옵저버 next에 매핑됨 |
| complete(): void       | 업스트림 옵저버블에서 완료 알림, next 무시됨                            |
| error(exception): void | 에러 알림 예외가 발생하여 더는 메시지를 보내지않음 next 무시됨          |

### 2.4.2 밑바닥부터 옵저버블 만들어보기

- 직접 구현해 본 구독
- 구독자가 구독하자마자 전달된 데이터를 사용하는 함수처럼 옵저버블이 동작한다는 점

- rxjs를 사용하면 Rx.Observable.create()로 옵저버 객체를 등록할 수 있다.
- next로 다음 방출 이벤트를 알리고 진행할 수 있음.

### 2.4.3 옵저버블 모듈

- 백분율 코드

---

- 옵저버블이 옵저버에 값을 전송 푸시 기반 매커니즘
- 이터레이터는 풀 기반 매커니즘

- 이터레이터와 제네레이터는 소비 코드가 소비 소비 속도를 제어함
- 즉 next나 yield를 사용하여 다음 값을 요청함

---

- DOM 같은 무수한 이벤트를 생성하는 이미터는 complete, error를 실행하지 않음
- 그러므로 구독 취소나 자동 구독 해제기능은 알아서 만들어야 함.

- complete, error, next 코드

- 옵저버에 관한 논의에서 중요한점은 콜백이 언제 호출될지 모르기때문에 다른 코드는 콜백 실행에 대해 가정을 해서는 안됨.

- 그래서 side effect를 피하고, 순수함수들로 코드를짜면 항상 올바른 결과를 얻을 수 있다.

---

- RXJS의 세가지 주요 부분인 생산자(옵저버블), 파이프라인(비즈니스 로직), 소비자(옵저버)를 만나보았다.

- 다음 장에서는 스트림에서 수행할 수 있는 연산과 필요할 때 이를 취소하는 방법을 자세히 알아봅니다.

### 2.5 요약

• RxJS와 좀 더 일반적으로 스트림에서의 사고 개념은 FP에서 많은 기본 원칙들을 도출합니다.

• RxJS의 선언적 스타일을 사용하면 거의 정확하게 문제를 나타내는 구문을 작동하는 코드로 변환할 수 있습니다.

• 데이터 소스는 옵저버블 계약에서도 매우 다르게 작동할 수 있습니다.

• 옵저버블 관점에서 볼 때 마우스 클릭, HTTP 요청 또는 간단한 배열은 모두 똑같습니다.

• 푸시 기반 방식과 풀 기반 방식은 각각 옵저버블과 이터레이터로 표현됩니다. 데이터 소스를 래핑하는 것은 파이프라인과 옵저버블을 만드는 첫 번째 단계입니다.

• 옵저버블은 생산, 소비, 처리를 완전히 독립된 구성으로 분리할 수 있게 이벤트의 생산 및 소비 개념을 추상화합니다.

• 옵저버는 next(), complete(), error() 세 가지 메서드로 API를 드러냅니다.
