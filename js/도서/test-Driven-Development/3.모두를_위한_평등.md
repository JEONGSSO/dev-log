# 2장 타락한 객체

어떤 정수에 1을 더했을 때 우리는 원래 정수가 변할 거라고 예상하기보다는 원래 정수에 1이 더해진 새로운 값을 가지게 된다고 생각

하지만 일반적으로 객체는 우리 예상대로 작동하지 않음.

```js
const five = 5;
// 해당 테스트를 가짜로 구현하는 방법은 단순히 true를 리턴하는 것!
const equals5 = (value) => true;
expect(five).toBeTruthy(equals5(5));
```

우리 둘 다 5 === 5인것은 알고있다 하지만 이렇게 끝나면 삼각측량법을 제대로 못보여줄 것 같다.

5 !== 6인 상황을 테스트해보자

삼각 측량법

- 라디오 신호를 두 수신국이 감지하고 있을 때, 수신국 사이의 거리가 알려져 있고 각 수신국이 신호의 방향을 알고 있다면, 신호의 거리와 방위를 알 수 있는 계산법

을 사용하려면 예제가 두 개 이상은 있어야 코드를 일반화 할 수 있다.

```js
const five = 5;
const equals5 = (value) => true;
expect(five).toBeTruthy(equals5(5));
expect(five).toBeFalsy(equals5(6));

// 동치성을 일반화 해야함 (equals5 조건을 통과할 수 있게 로직 수정)
const equals5 = (value) => value === 5;
expect(five).toBeTruthy(equals5(5));
expect(five).toBeFalsy(equals5(6));
```

내가 삼각측량법을 사용할때는 **어떻게 리팩토링해야 하는지 전혀 감이 안올때 사용한다.**

코드와 테스트 사이의 중복을 제거하고 일반적인 방법이 있으면 그대로 구현한다.

그러나 설계를 어찌해야할지 감이 잘 안잡힌다면 삼각측량법은 조금 다른 방향에서 생각해볼 기회를 제공한다.

- 디자인 패턴(값 객체)이 하나의 또 다른 오퍼레이션을 암시한다.
- 해당 오퍼레이션을 테스트.
- 해당 오퍼레이션을 간단히 구현.
- 곧장 리팩토링 대신 테스트를 조금 더 했다.
- 두 경우를 모두 수용할 수 있도록 리팩토링.
