함수형 사고를 하기 위하여

일단 크게 세가지로 나누자

- 액션

  - 부수효과를 동반하는 작업
  - mutation, put, 이메일 보내기, db읽기 등등
  - 실행 시점, 위치가 중요함

- 계산
  - add, join 등등
  - 항상 같은 값을 반환하는 단일책임의 순수함수로 작성
  - 언제 어디서 실행해도 무방함

```js
// 계산 예제

const add = (a, b) => a + b;
// Math에 있는 메서드들 전부
```

- 데이터
  - 있는 그대로의 값 ([1,2,3,4,5])
  - 이벤트에 대한 사실

자주쓰는 lodash pipe로 예를 들면

```js
// 계산
const pipe = (x0, ...fns) => fns.reduce((x, f) => f(x), x0);
const reduce = (f) => (arr) => arr.reduce(f);

const add = (a, b) => a + b;
const sumAges = (arr) => (f) => arr.reduce(f);

// 데이터
const peopleAges = [20, 21, 22];

// 액션
const submit = (value) =>
  fetch("localhost:3000", { body: JSON.stringify(value) });

const totalSum = pipe(peopleAges, reduce(add), submit);

console.log(totalSum); // 64
```

토니의 피자가게

기계 3대가 각각의 할당되어있는 작업을 진행한다.

```js
  // 기계 1        기계 2         기계 3   도우 펴기 부터는 기계 2가 담당
  소스 만들기 -> 반죽 만들기 -> 치즈 갈기 -> 도우 펴기 -> 소스 바르기 -> ...
```

각각의 기계들이 할당된 작업을 진행하기에 어느것이 먼저 될 지 예측할 수 없고

만약 기계2가 반죽을 만들고 도우를 펴고 소스를 바르려고 하는데

아직 기계1이 소스를 완성하지 못했다면 소스를 바르지 않고 진행하게되어 피자가 엉망이 될 수 있다.

즉, 실행 순서를 잘 지켜야 하는데

피자는 소스 만들기, 반죽 만들기, 치즈 갈기가 선행되어야 도우를 펴는 단계를 진행 할 수 있다고 하면

소스 만들기, 반죽 만들기, 치즈 갈기

\-------------------------------------- (점선으로 표시한 부분을 컷팅이라고 한다.)

도우 펴기 -> 소스 바르기 -> ...

각각의 기계들이 할당된 소스 만들기, 반죽 만들기, 치즈 갈기가 전부 준비된 상태여야 도우를 펴고 소스를 바르고 이제서야 피자를 만들 수 있다는 것.

특히 실행 순서가 중요할 때 이 컷팅이라는 방법을 사용하여 대기 한후 진행 하는 방법을 생각할 수 있다.

## 추천인이 10명 이상에게 이메일을 보내는 예제

이메일 리스트
| X | 이메일 | rec_count |
| --- | ------------- | --------- |
| | aaa@naver.com | 0 |
| | bbb@naver.com | 6 |
| | ccc@naver.com | 1 |
| | ddd@naver.com | 10 |
| | eee@naver.com | 0 |
| | fff@naver.com | 13 |

쿠폰 리스트
| X | 이메일 | discount_percent |
| --- | ------------- | --------- |
| | best | 15 |
| | good | 5 |
| | bad | 0 |

추천인이 10명 이상인 사람에게 best 쿠폰
모든유저에겐 good 쿠폰
bad쿠폰은 안씀

### 액션

- 이메일 보내기
- 이메일 리스트 목록 읽기
- 쿠폰 리스트 목록 읽기

### 계산

- 추천인 수에따른 쿠폰 등급 계산

### 데이터

- 이메일 리스트
- 쿠폰 리스트

액션에서 계산과 데이터로 분리 할 수 있으면 분리하는게 최선이고,
너무 세세하게 분리하는것도 좋지 않으니 타협점을 찾아야 한다.

데이터인 이메일 리스트와 쿠폰 리스트를 조합하여 추천인 계산
