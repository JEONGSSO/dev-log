3장에서 동치성 문제를 정의했으니 이를 이용하여 테스트가 조금 더 많은 이야기를 해줄 수 있도록 만들자.

```java
  Dollor five = new Dollor(5);
  Dollor product = five.times(2)
  assertEquals(10, product)
  // 이와같은 테스트를

  assertEquals(new Dollor(10), five.times(2))
  // 인라인으로 변경!
```

이 테스트는 일련의 오퍼레이션이 아니라 참인 명제에 대한 단언들로

의도를 더 명확히 이야기 할 수 있다.

테스트를 고치고 Dollar의 amount 인스턴스 변수를 사용하는 코드는 Dollor 자신밖에 없다.

이로써 amount 변수를 private하게 관리 할 수 있다.

    동치성 테스트가 동치성에 대한 코드가 정확히 작동한다는 것을 검증하는데에 실패한다면,
    곱하기 테스트 역시 곱하기에 대한 코드가 정확하게 작동한다는 것을 검증하는데 실패하게 된다.

이것은 TDD를 하면서 적극적으로 관리해야 할 위험 요소다!

우리는 완벽함을 위해 노력하지 않는다.

모든 것을 두 번 말함으로써(테스트와 코드)

자신감을 가지고 전진할 수 있을 만큼의 결함의 **정도와 빈도를 낮추기를 희망**하는 것이다

### 지금까지 배운 것?!

- 오직 테스트를 향상시키기 위해서만 개발된 기능을 사용.
- 두 테스트가 동시에 실패하면 망한다!!!
- 테스트와 코드 사이 결합도를 낮추기 위해 테스트하는 객체의 새기능을 사용.
